# Clarity – AI coding agent guide

Use these project-specific notes to be productive quickly. Keep changes aligned with existing patterns and Qt threading rules.

## Big picture
- Desktop music player (Python 3.12+, PySide6/QML).
- Entrypoint: `run.py` → initializes `src.universal` → starts UI in `src/app/main.py`.
- UI: QML in `src/app/qml` with context properties: `Theme`, `Backend`, `Interactions` (see `src/app/main.py`). Image providers for songs/albums are registered here.
- Core singletons created in `src/universal.py`: logging, settings, caches, queue, network, innertube search model, background workers. Most modules import from here.
- Playback: `src/playback` – `queue.Queue` manages list/state; playback backends implement `MediaPlayer` protocol (`player.py`) with default `VLCMediaPlayer` (`VlcPlayer.py`). Integrations: Windows SMTC (`src/wintube/winSMTC`), Discord presence (`src/discotube/presence`).
- Data sources: Provider-based architecture in `src/innertube` enables pluggable backends (`Song`, `Album`, `search`, `BasicSearchResultsModel`). Currently YouTube via `ytmusicapi` + `yt-dlp`.

## Developer workflows
- Install and run (dev mode with QML live reload via `main.debug()`):
  - PowerShell
    ```powershell
    python .\run.py
    ```
- Packaging (Nuitka): options embedded as `# nuitka-project:` in `run.py`. CI builds on push to `main` (`.github/workflows/main.yml`). For local Windows builds, invoke Nuitka standalone honoring those inline options.
- Profiling: use VS Code task “Profile main.py” (Austin). Ensure optional deps `[project.optional-dependencies].test` are installed.

## Versioning & releases
- `version.txt` is the release version consumed by CI and included in the binary.
- Conventional-commit style messages drive `autover.py`/`autochangelog.py`:
  - Types: `feat`, `fix`, `perf`, `refactor`, `chore`, `docs`; `BREAKING CHANGE` triggers major inc.
  - Example: `feat(queue): add debounced next/prev handling`.
- CI release: reads `MOST_RECENT_CHANGELOG` (generated by `autochangelog.py`) and uploads a zipped Nuitka build.

## Conventions and patterns
- Imports: use absolute `src.*` imports to avoid circulars. Note: `innertube/song/neosong.py` must NOT import `playback/queue`; use `src.universal.queueInstance` instead.
- Singletons: many classes use `__new__`/`instance()` (e.g., `Settings`, `QmlSettingsInterface`, `Backend`, `Song`). Prefer retrieving via the singleton accessor.
- Identifiers: All IDs use namespaced format `provider:type:id` (e.g., `youtube:song:dQw4w9WgXcQ`). Use identifier types from `src.innertube.globalModels`:
  - `SimpleIdentifier` - raw provider-specific ID (e.g., `dQw4w9WgXcQ`)
  - `NamespacedIdentifier` - provider + ID (e.g., `youtube:dQw4w9WgXcQ`)
  - `NamespacedTypedIdentifier` - full format with type (e.g., `youtube:song:dQw4w9WgXcQ`)
  - Song instances accept any of these formats or plain strings (auto-converted to typed format)
- Threading/Qt:
  - Do not block the Qt main thread. Heavy work should go through `universal.bgworker` or `universal.asyncBgworker` (see usage in `Backend.search`, `VLCMediaPlayer._do_play`).
  - Emit/forward Qt signals from the appropriate thread; UI state comes from `Queue` which re-emits player signals.
- Logging: `universal.install_json_logging()` installs a human-readable console formatter. Use `logging.getLogger(name)` over bare `print` (which is wrapped to add time/thread).
- Paths/runtime: `src/paths.Paths` chooses asset/QML roots based on compiled status from `src/misc/compiled.py` (`compiled.txt`). Use these for file access.

## Key modules and how to extend
- Song and providers (`src/innertube/song/`):
  - **Architecture**: Song class delegates to pluggable providers for data fetching. Data separated into `SongData` (metadata) and `PlaybackData` (streaming formats).
  - **Creating songs**: `Song("youtube:song:VIDEO_ID")` or `Song(NamespacedTypedIdentifier(...))`. Accepts plain strings (auto-converted to YouTube).
  - **Provider system**: Implement `ProviderInterface` protocol and register via `add_provider(name, ProviderClass)`. See `src/innertube/song/providers/youtube/` for reference.
  - **Data models**: Use dataclasses in `src/innertube/song/models/` (`SongData`, `PlaybackData`, `FormatData`). Providers parse raw API responses into these types.
  - **Caching**: Each provider has its own cache/datastore (e.g., `YoutubeProvider.CACHE`). Song uses provider-specific cache for `_info` and `_playbackinfo` keys.
  - **Accessing data**: `song.title`, `song.artist` work via `__getattribute__` forwarding to `song.data.title`. Direct access: use `song.data` (SongData) or `song.playbackInfo` (PlaybackData).
- Queue and playback (`src/playback/queuemanager.py`):
  - Add songs: `universal.queueInstance.add("youtube:song:VIDEO_ID", goto=True)` or pass `NamespacedTypedIdentifier`.
  - Swap player backends: `queue.swapPlayers(YourMediaPlayer())` – implement `MediaPlayer` protocol (`src/playback/MediaPlayerProtocol.py`).
  - Debounced next/prev and SMTC sync are built-in; preserve by emitting/forwarding the same signals.
- Networking (`src/network.py`):
  - Use `networkManager = NetworkManager.get_instance()` for all HTTP; it has retries, headers, proxy, and simple parallel download helpers. Returns `None` on failure.
- Caching (`src/cacheManager/cacheManager.py`):
  - Persistent caches are initialized in `universal` (e.g., `imageCache`, `albumCache`). Interact via `cacheManager.getCache(name).get/put/delete()`; keys must be fs-safe (no spaces or separators).
  - Provider-specific caches: `YoutubeProvider.CACHE` (songs_cache) and `YoutubeProvider.DATASTORE` (song downloads).
- Settings (`src/misc/settings.py`):
  - Add defaults to `src/app/assets/DEFAULTSETTINGS.json`. Values load into a tree model exposed via `Backend.settingsModel` and `QmlSettingsInterface.instance()` for QML (`Backend.settingsInterface`). Use `Setting.setValue()` to persist and notify.
- App URL routing (`src/AppUrl.py`, used via `Backend.url`):
  - QML drives navigation with `clarity:///page/<name>`; resolved to `src/app/qml/pages/*.qml` via `Backend.getCurrentPageFilePath`.

## QML integration examples
- Search from QML: call `Backend.search(query)`; results bind to `Backend.searchModel`.
- Queue model in QML: bind to `Backend.queueModel`; roles include `title`, `artist`, `length`, `id`, `index`.
- Dynamic theming: `Theme.get_dynamicColorsFromImage()` is invoked when the current song changes (`Backend.updateMaterialColors`).

## Gotchas
- Song identifiers: Always use namespaced format `youtube:song:ID`. Plain YouTube video IDs are auto-converted but explicit is better.
- `Queue` expects `Song.playbackReadyChanged` to trigger `queue.songMrlChanged(s)` so VLC picks up new MRLs; keep that link when altering `Song`.
- Provider lookups: `get_provider(namespace)` returns `None` for unknown providers. Always check before accessing provider attributes.
- Song data access: `song.title` works via forwarding to `song.data.title`, but for new attributes always add to `SongData` dataclass first.
- Check for `None` from `NetworkManager.get()` before using `.content`/`.status_code`.
- Long I/O and network must run off the UI thread; prefer background workers.
- When adding runtime assets/QML, respect `Paths.ASSETSPATH`, `Paths.QMLPATH`, and include in Nuitka via `# nuitka-project: --include-data-*` if needed.

## Notes on type checker
The type checker complains a lot about PySide6/PyQt6 types. You can ignore these warnings, or add `# type: ignore` to the relevant lines.
For example, the type checker thinks PySide6 properties are objects, not their underlying type, so please just ignore all those warnings and use the property anyway.


## Extra notes
Don't overcomment. Use comments to explain why something is done, not what is being done. The code should be clear enough to explain what is being done. Avoid redundant comments. For example, don't comment `self.x = 5  # Set x to 5`. Instead, if necessary, explain why `x` is set to 5.