# Clarity – AI coding agent guide

Use these project-specific notes to be productive quickly. Keep changes aligned with existing patterns and Qt threading rules.

## Big picture
- Desktop music player (Python 3.12+, PySide6/QML).
- Entrypoint: `run.py` → initializes `src.universal` → starts UI in `src/app/main.py`.
- UI: QML in `src/app/qml` with context properties: `Theme`, `Backend`, `Interactions` (see `src/app/main.py`). Image providers for songs/albums are registered here.
- Core singletons created in `src/universal.py`: logging, settings, caches, queue, network, innertube search model, background workers. Most modules import from here.
- Playback: `src/playback` – `queue.Queue` manages list/state; playback backends implement `MediaPlayer` protocol (`player.py`) with default `VLCMediaPlayer` (`VlcPlayer.py`). Integrations: Windows SMTC (`src/wintube/winSMTC`), Discord presence (`src/discotube/presence`).
- Data sources: YouTube Music via `ytmusicapi` wrappers in `src/innertube` (`Song`, `Album`, `search`, `BasicSearchResultsModel`).

## Developer workflows
- Install and run (dev mode with QML live reload via `main.debug()`):
  - PowerShell
    ```powershell
    python -m pip install --upgrade pip; pip install -e .
    python .\run.py
    ```
- Packaging (Nuitka): options embedded as `# nuitka-project:` in `run.py`. CI builds on push to `main` (`.github/workflows/main.yml`). For local Windows builds, invoke Nuitka standalone honoring those inline options.
- Profiling: use VS Code task “Profile main.py” (Austin). Ensure optional deps `[project.optional-dependencies].test` are installed.

## Versioning & releases
- `version.txt` is the release version consumed by CI and included in the binary.
- Conventional-commit style messages drive `autover.py`/`autochangelog.py`:
  - Types: `feat`, `fix`, `perf`, `refactor`, `chore`, `docs`; `BREAKING CHANGE` triggers major inc.
  - Example: `feat(queue): add debounced next/prev handling`.
- CI release: reads `MOST_RECENT_CHANGELOG` (generated by `autochangelog.py`) and uploads a zipped Nuitka build.

## Conventions and patterns
- Imports: use absolute `src.*` imports to avoid circulars. Note: `innertube/song.py` must NOT import `playback/queue`; use `src.universal.queueInstance` instead.
- Singletons: many classes use `__new__`/`instance()` (e.g., `Settings`, `QmlSettingsInterface`, `Backend`). Prefer retrieving via the singleton accessor.
- Threading/Qt:
  - Do not block the Qt main thread. Heavy work should go through `universal.bgworker` or `universal.asyncBgworker` (see usage in `Backend.search`, `VLCMediaPlayer._do_play`).
  - Emit/forward Qt signals from the appropriate thread; UI state comes from `Queue` which re-emits player signals.
- Logging: `universal.install_json_logging()` installs a human-readable console formatter. Use `logging.getLogger(name)` over bare `print` (which is wrapped to add time/thread).
- Paths/runtime: `src/paths.Paths` chooses asset/QML roots based on compiled status from `src/misc/compiled.py` (`compiled.txt`). Use these for file access.

## Key modules and how to extend
- Queue and playback (`src/playback/queue.py`):
  - Add songs: `universal.queueInstance.add("VIDEO_ID", goto=True)`.
  - Swap player backends: `queue.swapPlayers(YourMediaPlayer())` – implement `MediaPlayer` protocol (`src/playback/player.py`).
  - Debounced next/prev and SMTC sync are built-in; preserve by emitting/forwarding the same signals.
- Networking (`src/network.py`):
  - Use `networkManager = NetworkManager.get_instance()` for all HTTP; it has retries, headers, proxy, and simple parallel download helpers. Returns `None` on failure.
- Caching (`src/cacheManager/cacheManager.py`):
  - Persistent caches are initialized in `universal` (e.g., `imageCache`, `albumCache`). Interact via `cacheManager.getCache(name).get/put/delete()`; keys must be fs-safe (no spaces or separators).
- Settings (`src/misc/settings.py`):
  - Add defaults to `src/app/assets/DEFAULTSETTINGS.json`. Values load into a tree model exposed via `Backend.settingsModel` and `QmlSettingsInterface.instance()` for QML (`Backend.settingsInterface`). Use `Setting.setValue()` to persist and notify.
- App URL routing (`src/AppUrl.py`, used via `Backend.url`):
  - QML drives navigation with `clarity:///page/<name>`; resolved to `src/app/qml/pages/*.qml` via `Backend.getCurrentPageFilePath`.

## QML integration examples
- Search from QML: call `Backend.search(query)`; results bind to `Backend.searchModel`.
- Queue model in QML: bind to `Backend.queueModel`; roles include `title`, `artist`, `length`, `id`, `index`.
- Dynamic theming: `Theme.get_dynamicColorsFromImage()` is invoked when the current song changes (`Backend.updateMaterialColors`).

## Gotchas
- `Queue` expects `Song.playbackReadyChanged` to trigger `queue.songMrlChanged(s)` so VLC picks up new MRLs; keep that link when altering `Song`.
- Check for `None` from `NetworkManager.get()` before using `.content`/`.status_code`.
- Long I/O and network must run off the UI thread; prefer background workers.
- When adding runtime assets/QML, respect `Paths.ASSETSPATH`, `Paths.QMLPATH`, and include in Nuitka via `# nuitka-project: --include-data-*` if needed.

Questions or missing areas? Tell me what’s unclear (e.g., workers API, SMTC hooks, or packaging specifics) and I’ll refine this file.
